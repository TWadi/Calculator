/* 
 * File generated by ChatGPT (OpenAI) on 2025-08-01.
 * Adapted/edited by T.Wadi
 */


#include "stm32f4xx_hal.h"
#include "calculator_ui.h"
#include "ili9341.h"
#include "macros.h"
#include <string.h>
#include <math.h>

// 3x5 pixel font: each entry is 5 rows, 3 bits per row (MSB = left)
static const uint8_t font3x5[][5] = {
    {0b111, 0b101, 0b101, 0b101, 0b111}, // 0
    {0b010, 0b110, 0b010, 0b010, 0b111}, // 1
    {0b111, 0b001, 0b111, 0b100, 0b111}, // 2
    {0b111, 0b001, 0b111, 0b001, 0b111}, // 3
    {0b101, 0b101, 0b111, 0b001, 0b001}, // 4
    {0b111, 0b100, 0b111, 0b001, 0b111}, // 5
    {0b111, 0b100, 0b111, 0b101, 0b111}, // 6
    {0b111, 0b001, 0b010, 0b100, 0b100}, // 7
    {0b111, 0b101, 0b111, 0b101, 0b111}, // 8
    {0b111, 0b101, 0b111, 0b001, 0b111}, // 9
};

// Symbols
static const uint8_t sym_plus[5]  = {0b000, 0b010, 0b111, 0b010, 0b000}; // +
static const uint8_t sym_minus[5] = {0b000, 0b000, 0b111, 0b000, 0b000}; // -
static const uint8_t sym_eq[5]    = {0b000, 0b111, 0b000, 0b111, 0b000}; // =
static const uint8_t sym_div[5]   = {0b001, 0b001, 0b111, 0b100, 0b100}; // /
static const uint8_t sym_mul[5]   = {0b101, 0b010, 0b111, 0b010, 0b101}; // *
static const uint8_t sym_dot[5]   = {0b000, 0b000, 0b000, 0b000, 0b010}; // .
static const uint8_t sym_c[5]     = {0b011, 0b100, 0b100, 0b100, 0b011}; // C

static const uint8_t *glyph_for_char(char c)
{
    if (c >= '0' && c <= '9') return font3x5[c - '0'];
    switch (c) {
        case '+': return sym_plus;
        case '-': return sym_minus;
        case '=': return sym_eq;
        case '/': return sym_div;
        case '*': return sym_mul;
        case '.': return sym_dot;
        case 'C': return sym_c;
        default:  return NULL;
    }
}

/* draw a 3x5 character scaled, with background */
static void draw_char3x5(int x, int y, const uint8_t glyph[5], uint16_t fg, uint16_t bg, int scale)
{
    if (!glyph) return;
    ili9341_fill_rect(x, y, 3 * scale, 5 * scale, bg);
    for (int row = 0; row < 5; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 3; col++) {
            if (bits & (1 << (2 - col))) {
                ili9341_fill_rect(x + col * scale, y + row * scale, scale, scale, fg);
            }
        }
    }
}

/* draw a label-centered button */
static void draw_button(int x, int y, int w, int h, const char *label, uint16_t face, uint16_t border, uint16_t text_color)
{
    ili9341_fill_rect(x, y, w, h, face);
    // border
    for (int i = 0; i < w; ++i) {
        ili9341_draw_pixel(x + i, y, border);
        ili9341_draw_pixel(x + i, y + h - 1, border);
    }
    for (int i = 0; i < h; ++i) {
        ili9341_draw_pixel(x, y + i, border);
        ili9341_draw_pixel(x + w - 1, y + i, border);
    }

    // label
    int scale = 3;
    int len = strlen(label);
    int char_w = 3 * scale;
    int char_h = 5 * scale;
    int spacing = 1;
    int total_w = len * char_w + (len - 1) * spacing;
    int start_x = x + (w - total_w) / 2;
    int start_y = y + (h - char_h) / 2;
    for (int i = 0; i < len; i++) {
        const uint8_t *g = glyph_for_char(label[i]);
        if (g) {
            draw_char3x5(start_x + i * (char_w + spacing), start_y, g, text_color, face, scale);
        }
    }
}

/* full-screen calculator UI */
void draw_calculator(void)
{
    const int screen_w = ILI9341_WIDTH;
    const int screen_h = ILI9341_HEIGHT;
    const int margin = 8;
    const int body_x = margin;
    const int body_y = margin;
    const int body_w = screen_w - 2 * margin;
    const int body_h = screen_h - 2 * margin;

    // body background
    ili9341_fill_rect(body_x, body_y, body_w, body_h, ili9341_color565(220, 220, 220));

    // display window (with border)
    const int disp_pad = 12;
    int disp_x = body_x + disp_pad;
    int disp_y = body_y + disp_pad;
    int disp_w = body_w - 2 * disp_pad;
    int disp_h = 60;

    // outer border
    ili9341_fill_rect(disp_x - 3, disp_y - 3, disp_w + 6, disp_h + 6, ILI9341_COLOR_WHITE);
    ili9341_fill_rect(disp_x - 2, disp_y - 2, disp_w + 4, disp_h + 4, ILI9341_COLOR_BLACK);
    ili9341_fill_rect(disp_x, disp_y, disp_w, disp_h, ILI9341_COLOR_BLACK);

    // Buttons layout (4x5)
    const char *labels[5][4] = {
        {"7", "8", "9", "/"},
        {"4", "5", "6", "*"},
        {"1", "2", "3", "-"},
        {"0", ".", "=", "+"},
        {"C", "",  "",  ""}  // clear and empty slots
    };

    int btn_cols = 4;
    int btn_rows = 5;
    int grid_x = body_x + disp_pad;
    int grid_y = disp_y + disp_h + 12;
    int grid_w = body_w - 2 * disp_pad;
    int grid_h = body_h - (disp_h + disp_pad + 12);
    int spacing = 6;

    int btn_w = (grid_w - (btn_cols - 1) * spacing) / btn_cols;
    int btn_h = (grid_h - (btn_rows - 1) * spacing) / btn_rows;

    for (int row = 0; row < btn_rows; row++) {
        for (int col = 0; col < btn_cols; col++) {
            const char *lbl = labels[row][col];
            if (!lbl[0]) continue;
            int x = grid_x + col * (btn_w + spacing);
            int y = grid_y + row * (btn_h + spacing);
            draw_button(x, y, btn_w, btn_h, lbl,
                        ili9341_color565(200, 200, 200), // face
                        ILI9341_COLOR_BLACK,             // border
                        ILI9341_COLOR_BLUE);              // label color
        }
    }

    // Initial value in display ("123"), right-aligned
    const char *value = "123";
    int scale = 4;
    int char_w = 3 * scale;
    int spacing_text = 2;
    int len = strlen(value);
    int total_w = len * char_w + (len - 1) * spacing_text;
    int value_x = disp_x + disp_w - total_w - 6; // right padding
    int value_y = disp_y + (disp_h - 5 * scale) / 2;
    for (int i = 0; i < len; i++) {
        const uint8_t *g = glyph_for_char(value[i]);
        if (g) {
            draw_char3x5(value_x + i * (char_w + spacing_text), value_y, g,
                        ILI9341_COLOR_WHITE, ILI9341_COLOR_BLACK, scale);
        }
    }
}
